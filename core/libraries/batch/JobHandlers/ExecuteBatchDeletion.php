<?php

namespace EventEspressoBatchRequest\JobHandlers;

use EE_Change_Log;
use EE_Registry;
use EE_Transaction;
use EEM_Event;
use EEM_Price;
use EEM_Ticket;
use EventEspresso\core\exceptions\InvalidClassException;
use EventEspresso\core\exceptions\InvalidDataTypeException;
use EventEspresso\core\exceptions\InvalidInterfaceException;
use EventEspresso\core\exceptions\UnexpectedEntityException;
use EventEspresso\core\services\loaders\LoaderFactory;
use EventEspresso\core\services\orm\tree_traversal\NodeGroupDao;
use EventEspresso\core\services\orm\tree_traversal\ModelObjNode;
use EventEspressoBatchRequest\Helpers\BatchRequestException;
use EventEspressoBatchRequest\Helpers\JobParameters;
use EventEspressoBatchRequest\Helpers\JobStepResponse;
use EventEspressoBatchRequest\JobHandlerBaseClasses\JobHandler;
use InvalidArgumentException;

/**
 * Class EventDeletion
 *
 * Given a job code (eg generated by PreviewEventDeletion), performs the deletion of the indicated items.
 *
 * @package     Event Espresso
 * @author         Mike Nelson
 * @since         $VID:$
 *
 */
class ExecuteBatchDeletion extends JobHandler
{
    /**
     * @var NodeGroupDao
     */
    protected $model_obj_node_group_persister;
    public function __construct(NodeGroupDao $model_obj_node_group_persister)
    {
        $this->model_obj_node_group_persister = $model_obj_node_group_persister;
    }


    // phpcs:disable PSR1.Methods.CamelCapsMethodName.NotCamelCaps
    /**
     *
     * @param JobParameters $job_parameters
     * @throws BatchRequestException
     * @return JobStepResponse
     */
    public function create_job(JobParameters $job_parameters)
    {
        $deletion_job_code = $job_parameters->request_datum('deletion_job_code', null);
        $roots = $this->model_obj_node_group_persister->getModelObjNodesInGroup($deletion_job_code);
        if ($roots === null) {
            throw new UnexpectedEntityException($roots, 'array', esc_html__('The job seems to be stale. Please press the back button in your browser twice.', 'event_espresso'));
        }
        $models_and_ids_to_delete = [];
        foreach ($roots as $root) {
            if (! $root instanceof ModelObjNode) {
                throw new UnexpectedEntityException($root, 'ModelObjNode');
            }
            $models_and_ids_to_delete = array_replace_recursive($models_and_ids_to_delete, $root->getIds());
        }
        $job_parameters->set_extra_data(
            [
                'models_and_ids_to_delete' => $models_and_ids_to_delete
            ]
        );
        // Find the job's actual size.
        $job_size = 0;
        foreach ($models_and_ids_to_delete as $model_name => $ids) {
            $job_size += count($ids);
        }
        $job_parameters->set_job_size($job_size);
        return new JobStepResponse(
            $job_parameters,
            esc_html__('Beginning to delete items...', 'event_espresso')
        );
    }

    /**
     * Performs another step of the job
     * @param JobParameters $job_parameters
     * @param int $batch_size
     * @return JobStepResponse
     * @throws BatchRequestException
     */
    public function continue_job(JobParameters $job_parameters, $batch_size = 50)
    {
        // We already have the items IDs. So deleting is really fast. Let's speed it up.
        $batch_size *= 10;
        $units_processed = 0;
        $models_and_ids_to_delete = $job_parameters->extra_datum('models_and_ids_to_delete', []);
        // Build a new list of everything leftover after this request's of deletions.
        $models_and_ids_remaining = [];
        foreach ($models_and_ids_to_delete as $model_name => $ids_to_delete) {
            if ($units_processed < $batch_size) {
                $model = EE_Registry::instance()->load_model($model_name);
                if ($model instanceof \EEM_Registration) {
                    // Now THIS could be a command!
                    $units_processed += $this->deleteRegistrationsAndTransactions($ids_to_delete, $batch_size - $units_processed, $job_parameters);
                } else {
                    $ids_to_delete_this_query = array_slice($ids_to_delete, 0, $batch_size - $units_processed, true);
                    if ($model->has_primary_key_field()) {
                        $where_conditions = [
                            $model->primary_key_name() => [
                                'IN',
                                $ids_to_delete_this_query
                            ]
                        ];
                    } else {
                        $where_conditions = [
                            'OR' => []
                        ];
                        foreach ($ids_to_delete_this_query as $index_primary_key_string) {
                            $keys_n_values = $model->parse_index_primary_key_string($index_primary_key_string);
                            $where_conditions['OR'][ 'AND*' . $index_primary_key_string ] = $keys_n_values;
                        }
                    }
                    // Deleting time!
                    // The model's deletion method reports every ROW deleted, and in the case of CPT models that will be
                    // two rows deleted for event CPT item. So don't rely on it for the count of items deleted.
                    $model->delete_permanently(
                        [
                            $where_conditions
                        ],
                        false
                    );
                    $units_processed += count($ids_to_delete_this_query);
                    $remaining_ids = array_diff_key($ids_to_delete, $ids_to_delete_this_query);
                    // If there's any more from this model, we'll do them next time.
                    if (count($remaining_ids) > 0) {
                        $models_and_ids_remaining[ $model_name ] = $remaining_ids;
                    }
                }
            } else {
                $models_and_ids_remaining[ $model_name ] = $models_and_ids_to_delete[ $model_name ];
            }
        }
        $job_parameters->mark_processed($units_processed);
        // All done deleting for this request. Is there anything to do next time?
        if (empty($models_and_ids_remaining)) {
            $job_parameters->set_status(JobParameters::status_complete);
            return new JobStepResponse(
                $job_parameters,
                esc_html__('Deletion complete.', 'event_espresso')
            );
        }
        $job_parameters->add_extra_data('models_and_ids_to_delete', $models_and_ids_remaining);
        return new JobStepResponse(
            $job_parameters,
            sprintf(
                esc_html__('Deleted %d items.', 'event_espresso'),
                $units_processed
            )
        );
    }

    /**
     * @since $VID:$
     * @param $reg_ids
     * @param $batch_size
     * @param JobParameters $job_parameters
     * @return int
     * @throws InvalidArgumentException
     * @throws InvalidDataTypeException
     * @throws InvalidInterfaceException
     * @throws \EE_Error
     * @throws \ReflectionException
     */
    protected function deleteRegistrationsAndTransactions($reg_ids, $batch_size, JobParameters $job_parameters){
        $count_deleted = 0;
        foreach($reg_ids as $reg_id){
            $count_deleted += $this->deleteRegistrationAndTransaction($reg_id, $job_parameters);
            if($count_deleted >= $batch_size){
                return $count_deleted;
            }
        }
        return $count_deleted;
    }

    /**
     * @since $VID:$
     * @param $reg_id
     * @return int
     * @throws \EE_Error
     * @throws \EventEspresso\core\exceptions\InvalidDataTypeException
     * @throws \EventEspresso\core\exceptions\InvalidInterfaceException
     * @throws \InvalidArgumentException
     * @throws \ReflectionException
     */
    protected function deleteRegistrationAndTransaction($reg_id, JobParameters $job_parameters){
        // If the registration's transaction has no other valid registrations, delete it, and its dependent data too.
        $TXN = \EEM_Transaction::instance()->get_one(
            [
                [
                    'Registration.REG_ID' => $reg_id
                ]
            ]
        );
        $count_deleted = 0;
        if( $TXN instanceof EE_Transaction) {
            $valid_regs = $TXN->count_related(
                'Registration',
                [
                    [
                        'REG_deleted' => false,
                        'Event.status' => ['!=', EEM_Event::post_status_trashed]
                    ]
                ]);
            if(! $valid_regs){
                // delete the transaction
                // and its dependent data
                $transaction_as_root_of_tree = new ModelObjNode($TXN->ID(), $TXN->get_model());
                $transaction_as_root_of_tree->visit(1000);
                $ids_to_delete = $transaction_as_root_of_tree->getIds();
                foreach($ids_to_delete as $model_name => $ids){
                    // just grab the IDs the easy way, there's no Term_Relationship model related to transactions
                    $model_to_delete = EE_Registry::instance()->load_model($model_name);
                    $deleted_from_this_model = $model_to_delete->delete_permanently(
                        [
                            [
                                $model_to_delete->primary_key_name() => ['IN', $ids]
                            ]
                        ],
                        false
                    );
                    // We discovered something new. Increase the job size.
                    $job_parameters->set_job_size(
                        $job_parameters->job_size() + $deleted_from_this_model
                    );
                    $count_deleted += $deleted_from_this_model;
                }
            }
        } else {
            // Get rid of the registration now.
            $count_deleted += \EEM_Registration::instance()->delete_permanently(
                [
                    [
                        'REG_ID' => $reg_id
                    ]
                ],
                false
            );
        }
        return $count_deleted;
    }


    /**
     * Performs any clean-up logic when we know the job is completed
     * @param JobParameters $job_parameters
     * @return JobStepResponse
     */
    public function cleanup_job(JobParameters $job_parameters)
    {
        $this->model_obj_node_group_persister->deleteModelObjNodesInGroup(
            $job_parameters->request_datum('deletion_job_code')
        );
        // For backwards compatibility with how we used to delete events, make sure we still trigger the old action.
        $models_and_ids_to_delete = $job_parameters->extra_datum('models_and_ids_to_delete', []);
        foreach ($models_and_ids_to_delete['Event'] as $event_id) {
            // Create a log entry so we know who and when this event was permanently deleted.
            (EE_Change_Log::new_instance(
                [
                    'OBJ_ID' => $event_id,
                    'OBJ_type' => 'Event',
                    'LOG_message' => sprintf(
                        esc_html__('Event %1$d permanently deleted using ExecuteBatchDeletion.', 'event_espresso'),
                        $event_id
                    )
                ]
            ))->save();
            do_action('AHEE__Events_Admin_Page___permanently_delete_event__after_event_deleted', $event_id);
        }
        return new JobStepResponse(
            $job_parameters,
            esc_html__('All done', 'event_espresso')
        );
    }
}
// End of file EventDeletion.php
// Location: EventEspressoBatchRequest\JobHandlers/EventDeletion.php
